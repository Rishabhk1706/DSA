https://www.naukri.com/code360/problems/maze-obstacles_977241?leftPanelTabValue=PROBLEM

//MEMORIZATION - Time - O(N x M)  Space - O((N-1) + (M-1)) + O(N x M)

import java.util.*;
public class Solution {
    static int mod = 1000000007;
    public static int f(int[][] dp, int i, int j, ArrayList<ArrayList<Integer>> mat){
        if(i>=0 && j>=0 && mat.get(i).get(j)==-1) return 0;
		if(i==0 && j==0){
			return 1;
		}
		if(i<0 || j<0){
			return 0;
		}
		if(dp[i][j] != -1) return dp[i][j];
		int top = f(dp,i-1,j,mat);
		int left = f(dp,i,j-1,mat);
		return dp[i][j] = (left+top)%mod;
	}
    static int mazeObstacles(int n, int m, ArrayList<ArrayList<Integer>> mat) {
        int[][] dp = new int[n][m];
		for(int i=0;i<n;i++){
			Arrays.fill(dp[i],-1);
		}
		return f(dp,n-1,m-1,mat);
    }
}

// TABULATION - Time - O(N x M)  Space - O(N x M)

import java.util.*;
public class Solution {
	static int mod = 1000000007;
    static int mazeObstacles(int n, int m, ArrayList<ArrayList<Integer>> mat) {
        int[][] dp = new int[n][m];
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				if(mat.get(i).get(j)==-1){
					dp[i][j]=0;
				}
				else if(i==0 && j==0){
					dp[i][j] = 1;
				}
				else{
					int top=0,left=0;
					if(i>0) top = dp[i-1][j];
					if(j>0) left = dp[i][j-1];
					dp[i][j] = (top+left)%mod;
				}
			}
		}
		return dp[n-1][m-1];
    }
}

// TABULATION - Time - O(N x m)  Space - O(N)

import java.util.*;
public class Solution {
	static int mod = 1000000007;
    static int mazeObstacles(int n, int m, ArrayList<ArrayList<Integer>> mat) {
        int[] dp = new int[m];
		for(int i=0;i<n;i++){
			int[] cur = new int[m];
			for(int j=0;j<m;j++){
				if(mat.get(i).get(j)==-1){
					cur[j]=0;
				}
				else if(i==0 && j==0){
					cur[j] = 1;
				}
				else{
					int top=0,left=0;
					if(i>0) top = dp[j];
					if(j>0) left = cur[j-1];
					cur[j] = (top+left)%mod;
				}
			}
			dp=cur;
		}
		return dp[m-1];
    }
}